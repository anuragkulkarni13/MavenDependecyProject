package vulnerability;

import java.nio.file.Files;
import java.nio.file.Paths;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.json.JSONArray;
import org.json.JSONObject;

import cache.DependencyCache;
import common.Utils;
import common.dto.DependencyDTO;
import common.dto.VersionDTO;
import common.dto.VulnerabilityDTO;
import dependency.DependencyOperations;
import pomanalyzer.PomOperations;
import versionmanagement.VersionFetcher;

public class VulnerabilityAnalyzer {

	// scans the vulnerability report, updates the node and generates the analysis
	
	public static String getleastVulCountVersion(String pomFileLocation, String pomLocation, String dependencyTreeLocation, 
			String dependencyCheckReportLocation, String groupId, String artifactId, String currentVersion, 
			String filePath, Connection connection){
		
		int leastVulCount = 0;
		String leastVulCountVersion = "";
		
		long fromTime = VersionFetcher.getTimeStampforDependency(groupId, artifactId, currentVersion);
		long toTime = 1677177000000L;
		
		boolean restrictToMajorPatchVersion = true;
		List<VersionDTO> versions = VersionFetcher.fetchAllVersions(groupId, artifactId, currentVersion, restrictToMajorPatchVersion, fromTime, toTime);

		List<String> versionList = new ArrayList<String>();

		if(!versions.isEmpty())
		{
			for(int i=versions.size()-1;i>=0;i--)
			{
				if(versions.get(i).getTimestamp()>=fromTime && versions.get(i).getTimestamp()<=toTime)
				{
					versionList.add(versions.get(i).getVersion());
				}
			}
		}
		
		if(versionList.size()>1)
		{
			for(String version : versionList)
			{
				PomOperations.updateDependencyVersion(pomFileLocation, groupId, artifactId, version);

				int vulCount = 0;
				try {
					String key = groupId +"/"+ artifactId +"/"+ version;
					if(DependencyCache.isKeyPresent(connection, key))
					{
						vulCount = Integer.parseInt(DependencyCache.getCache(connection, key));
					}
					else
					{
						DependencyOperations.generateDependencyCheckReportWithPath(pomFileLocation, pomLocation, dependencyCheckReportLocation);
						Map<String, List<VulnerabilityDTO>> vulnerabilityMap = getVulnerabilityList(dependencyCheckReportLocation);
						
						for (Map.Entry<String, List<VulnerabilityDTO>> entry : vulnerabilityMap.entrySet()) {
//						    System.out.println("Key: " + entry.getKey() + ", Value: " + entry.getValue().size());
						    vulCount += entry.getValue().size();
						}
						DependencyCache.putCache(connection, key, String.valueOf(vulCount));
					}
					
					System.out.println(key+" - "+vulCount);
				} catch (SQLException e) {
					e.printStackTrace();
				}
				
				if(version.equalsIgnoreCase(currentVersion))
				{
					leastVulCount = vulCount;
				}
				else
				{
					if(vulCount<leastVulCount)
					{
						leastVulCount = vulCount;
						leastVulCountVersion = version;
					}
				}
			}
			if(leastVulCountVersion.equalsIgnoreCase(""))
			{
				return currentVersion;
			}
		}
		else
		{
			return currentVersion;
		}

		return leastVulCountVersion;
	}
	
	public static Map<String, List<VulnerabilityDTO>> getVulnerabilityList(String dependencyCheckReportLocation)
	{
		Map<String, List<VulnerabilityDTO>> vulnerabilitiesMap = new HashMap<>();

		try {
			String content = new String(Files.readAllBytes(Paths.get(dependencyCheckReportLocation)));
			JSONObject jsonObject = new JSONObject(content);
			// Check if the "dependencies" array exists and is not null
			if (jsonObject.has("dependencies") && !jsonObject.isNull("dependencies")) {
				// Ensure that "dependencies" is actually a JSONArray
				if (jsonObject.get("dependencies") instanceof JSONArray) {
					JSONArray dependencyArray = jsonObject.getJSONArray("dependencies");
					for (int i = 0; i < dependencyArray.length(); i++) {

						List<VulnerabilityDTO> vulnerabilityList = new ArrayList<>();

						JSONObject dependencyObject = dependencyArray.getJSONObject(i);
						String fileName = dependencyObject.getString("fileName");
						String filePath = dependencyObject.getString("filePath");
						String[] filePathArr = filePath.split("\\\\");
						String artifactId = filePathArr[filePathArr.length - 3];
						String dependencyVersion = filePathArr[filePathArr.length - 2];
//                      System.out.println("filename : "+fileName);
						if (dependencyObject.has("vulnerabilities") && !dependencyObject.isNull("vulnerabilities")) {
							// Ensure that "dependencies" is actually a JSONArray
							if (dependencyObject.get("vulnerabilities") instanceof JSONArray) {
								JSONArray vulnerabilityArray = dependencyObject.getJSONArray("vulnerabilities");
								for (int j = 0; j < vulnerabilityArray.length(); j++) {

									JSONObject vulnerabilityObject = vulnerabilityArray.getJSONObject(j);
									String source = "";
									String vulnerabilityName = "";
									String severity = "";
									float baseScore = 0;
									String attackVector = "";
									String attackComplexity = "";
									String privilegesRequired = "";
									String userInteraction = "";
									String scope = "";
									String confidentialityImpact = "";
									String integrityImpact = "";
									String availabilityImpact = "";
									String baseSeverity = "";
									String exploitabilityScore = "";
									String impactScore = "";
									String version = "";

									source = vulnerabilityObject.getString("source");
									vulnerabilityName = vulnerabilityObject.getString("name");
									severity = vulnerabilityObject.getString("severity");
									if(vulnerabilityObject.has("cvssv3"))
									{
										JSONObject cvssv3Object = vulnerabilityObject.getJSONObject("cvssv3");
										baseScore = cvssv3Object.has("score")?cvssv3Object.getFloat("baseScore"):0;
										attackVector = cvssv3Object.has("score")?cvssv3Object.getString("attackVector"):"";
										attackComplexity = cvssv3Object.has("score")?cvssv3Object.getString("attackComplexity"):"";
										privilegesRequired = cvssv3Object.has("score")?cvssv3Object.getString("privilegesRequired"):"";
										userInteraction = cvssv3Object.has("score")?cvssv3Object.getString("userInteraction"):"";
										scope = cvssv3Object.has("score")?cvssv3Object.getString("scope"):"";
										confidentialityImpact = cvssv3Object.has("score")?cvssv3Object.getString("confidentialityImpact"):"";
										integrityImpact = cvssv3Object.has("score")?cvssv3Object.getString("integrityImpact"):"";
										availabilityImpact = cvssv3Object.has("score")?cvssv3Object.getString("availabilityImpact"):"";
										baseSeverity = cvssv3Object.has("score")?cvssv3Object.getString("baseSeverity"):"";
										exploitabilityScore = cvssv3Object.has("score")?cvssv3Object.getString("exploitabilityScore"):"";
										impactScore = cvssv3Object.has("score")?cvssv3Object.getString("impactScore"):"";
										version = cvssv3Object.has("score")?cvssv3Object.getString("version"):"";
									}
									else if(vulnerabilityObject.has("cvssv2"))
									{
										JSONObject cvssv2Object = vulnerabilityObject.getJSONObject("cvssv2");
										baseScore = cvssv2Object.has("score")?cvssv2Object.getFloat("score"):0;
										attackVector = cvssv2Object.has("accessVector")?cvssv2Object.getString("accessVector"):"";
										attackComplexity = cvssv2Object.has("accessComplexity")?cvssv2Object.getString("accessComplexity"):"";
										privilegesRequired = cvssv2Object.has("authenticationr")?cvssv2Object.getString("authenticationr"):"";
										confidentialityImpact = cvssv2Object.has("confidentialImpact")?cvssv2Object.getString("confidentialImpact"):"";
										integrityImpact = cvssv2Object.has("integrityImpact")?cvssv2Object.getString("integrityImpact"):"";
										availabilityImpact = cvssv2Object.has("availabilityImpact")?cvssv2Object.getString("availabilityImpact"):"";
										baseSeverity = cvssv2Object.has("severity")?cvssv2Object.getString("severity"):"";
										exploitabilityScore = cvssv2Object.has("exploitabilityScore")?cvssv2Object.getString("exploitabilityScore"):"";
										impactScore = cvssv2Object.has("impactScore")?cvssv2Object.getString("impactScore"):"";
										version = cvssv2Object.has("version")?cvssv2Object.getString("version"):"";
									}

									VulnerabilityDTO vulnerabilityDTO = new VulnerabilityDTO();
//									vulnerabilityDTO.setJarName(fileName);
									vulnerabilityDTO.setArtifactId(artifactId);
									vulnerabilityDTO.setDependencyVersion(dependencyVersion);
									vulnerabilityDTO.setSource(source);
									vulnerabilityDTO.setVulnerabilityName(vulnerabilityName);
									vulnerabilityDTO.setSeverity(severity);
									vulnerabilityDTO.setBaseScore(baseScore);
									vulnerabilityDTO.setAttackVector(attackVector);
									vulnerabilityDTO.setAttackComplexity(attackComplexity);
									vulnerabilityDTO.setPrivilegesRequired(privilegesRequired);
									vulnerabilityDTO.setUserInteraction(userInteraction);
									vulnerabilityDTO.setScope(scope);
									vulnerabilityDTO.setConfidentialityImpact(confidentialityImpact);
									vulnerabilityDTO.setIntegrityImpact(integrityImpact);
									vulnerabilityDTO.setAvailabilityImpact(availabilityImpact);
									vulnerabilityDTO.setBaseSeverity(baseSeverity);
									vulnerabilityDTO.setExploitabilityScore(exploitabilityScore);
									vulnerabilityDTO.setImpactScore(impactScore);
									vulnerabilityDTO.setVersion(version);

//                            		System.out.println(vulnerabilityDTO.getJarName());
									vulnerabilityList.add(vulnerabilityDTO);
								}
							}
						}
						if(vulnerabilityList.size()>0)
						{
							vulnerabilitiesMap.put(artifactId, vulnerabilityList);
						}
					}
				}
			}	        
		}
		catch(Exception e)
		{
			e.printStackTrace();
		}

		return vulnerabilitiesMap;

	}

	public static void getVulCount(DependencyDTO root, Map<String,Integer> vulCount)
	{
		if(root.getVulnerabilities().size()>0)
		{
			vulCount.put(root.getGroupId()+"/"+root.getArtifactId()+"/"+root.getVersion(), root.getVulnerabilities().size());			
			System.out.println(root.getArtifactId()+" - "+root.getVersion()+" - "+root.getVulnerabilities().size());		
//			for(VulnerabilityDTO vul : root.getVulnerabilities())
//			{
//				System.out.println(vul.getVulnerabilityName());
//			}
		}
		List<DependencyDTO> children = root.getChildren();
		for(DependencyDTO child : children)
		{
			getVulCount(child, vulCount);
		}
	}

	public static int getTotalVulCount(Map<String,Integer> vulCount)
	{
		int totalVulCount = 0;
		for (Integer value : vulCount.values()) {
			totalVulCount += value;
		}
		return totalVulCount;
	}

	
	
	
	
	
	
	
	
	
	
	
	
//	public static String getleastVulCountVersion(String pomFileLocation, String pomLocation, String dependencyTreeLocation, 
//			String dependencyCheckReportLocation, String groupId, String artifactId, String currentVersion, 
//			String filePath, Connection connection){
//		
//		long fromTime = VersionFetcher.getTimeStampforDependency(groupId, artifactId, currentVersion);
//		long toTime = 1677177000000L;
//		
//		boolean restrictToMajorPatchVersion = true;
//		List<VersionDTO> versions = VersionFetcher.fetchAllVersions(groupId, artifactId, currentVersion, restrictToMajorPatchVersion, fromTime, toTime);
//
//		List<String> versionList = new ArrayList<String>();
//
//		for(VersionDTO v : versions)
//		{
//			if(v.getTimestamp()>=fromTime && v.getTimestamp()<=toTime)
//			{
//				versionList.add(v.getVersion());
//			}
//		}
//		
//		if(versionList.size()>1)
//		{
//			for(String version : versionList)
//			{
//				PomOperations.updateDependencyVersion(pomFileLocation, groupId, artifactId, version);
//				DependencyOperations.generateDependencyTreeWithPath(pomFileLocation, pomLocation, dependencyTreeLocation);
//				DependencyDTO dependencyRoot = DependencyOperations.getDependencyTree(dependencyTreeLocation);
//				Map<String,Integer> vulCount = new HashMap<>();
//
//				try {
//					String key = groupId +"/"+ artifactId +"/"+ version;
//					if(DependencyCache.isKeyPresent(connection, key))
//					{
//						vulCount = DependencyCache.getCache(connection, key);
//					}
//					else
//					{
//						DependencyOperations.generateDependencyCheckReportWithPath(pomFileLocation, pomLocation, dependencyCheckReportLocation);
//						Map<String, List<VulnerabilityDTO>> vulnerabilityMap = getVulnerabilityList(dependencyCheckReportLocation);
//						//check if this update is required
//						dependencyRoot.updateVulberabilities(vulnerabilityMap);
//						getVulCount(dependencyRoot, vulCount);
//						DependencyCache.putCache(connection, key, vulCount);
//					}
//				} catch (SQLException e) {
//					e.printStackTrace();
//				}
//
////				writeMapToFile(filePath, dependencyRoot.getChildren().get(0),vulCount);
//				Utils.writeMapToFile(filePath, dependencyRoot,vulCount);
//				int totalVulCount = getTotalVulCount(vulCount);
//			}
//		}
//		else
//		{
//			return currentVersion;
//		}
//		
//		return "";
//	}
//	
//	public static Map<String, List<VulnerabilityDTO>> getVulnerabilityList(String dependencyCheckReportLocation)
//	{
//		Map<String, List<VulnerabilityDTO>> vulnerabilitiesMap = new HashMap<>();
//
//		try {
//			String content = new String(Files.readAllBytes(Paths.get(dependencyCheckReportLocation)));
//			JSONObject jsonObject = new JSONObject(content);
//			// Check if the "dependencies" array exists and is not null
//			if (jsonObject.has("dependencies") && !jsonObject.isNull("dependencies")) {
//				// Ensure that "dependencies" is actually a JSONArray
//				if (jsonObject.get("dependencies") instanceof JSONArray) {
//					JSONArray dependencyArray = jsonObject.getJSONArray("dependencies");
//					for (int i = 0; i < dependencyArray.length(); i++) {
//
//						String fileName = "";
//						List<VulnerabilityDTO> vulnerabilityList = new ArrayList<>();
//
//						JSONObject dependencyObject = dependencyArray.getJSONObject(i);
//						fileName = dependencyObject.getString("fileName");
//						//                        System.out.println("filename : "+fileName);
//						if (dependencyObject.has("vulnerabilities") && !dependencyObject.isNull("vulnerabilities")) {
//							// Ensure that "dependencies" is actually a JSONArray
//							if (dependencyObject.get("vulnerabilities") instanceof JSONArray) {
//								JSONArray vulnerabilityArray = dependencyObject.getJSONArray("vulnerabilities");
//								for (int j = 0; j < vulnerabilityArray.length(); j++) {
//
//									JSONObject vulnerabilityObject = vulnerabilityArray.getJSONObject(j);
//									String source = "";
//									String vulnerabilityName = "";
//									String severity = "";
//									float baseScore = 0;
//									String attackVector = "";
//									String attackComplexity = "";
//									String privilegesRequired = "";
//									String userInteraction = "";
//									String scope = "";
//									String confidentialityImpact = "";
//									String integrityImpact = "";
//									String availabilityImpact = "";
//									String baseSeverity = "";
//									String exploitabilityScore = "";
//									String impactScore = "";
//									String version = "";
//
//									source = vulnerabilityObject.getString("source");
//									vulnerabilityName = vulnerabilityObject.getString("name");
//									severity = vulnerabilityObject.getString("severity");
//									if(vulnerabilityObject.has("cvssv3"))
//									{
//										JSONObject cvssv3Object = vulnerabilityObject.getJSONObject("cvssv3");
//										baseScore = cvssv3Object.has("score")?cvssv3Object.getFloat("baseScore"):0;
//										attackVector = cvssv3Object.has("score")?cvssv3Object.getString("attackVector"):"";
//										attackComplexity = cvssv3Object.has("score")?cvssv3Object.getString("attackComplexity"):"";
//										privilegesRequired = cvssv3Object.has("score")?cvssv3Object.getString("privilegesRequired"):"";
//										userInteraction = cvssv3Object.has("score")?cvssv3Object.getString("userInteraction"):"";
//										scope = cvssv3Object.has("score")?cvssv3Object.getString("scope"):"";
//										confidentialityImpact = cvssv3Object.has("score")?cvssv3Object.getString("confidentialityImpact"):"";
//										integrityImpact = cvssv3Object.has("score")?cvssv3Object.getString("integrityImpact"):"";
//										availabilityImpact = cvssv3Object.has("score")?cvssv3Object.getString("availabilityImpact"):"";
//										baseSeverity = cvssv3Object.has("score")?cvssv3Object.getString("baseSeverity"):"";
//										exploitabilityScore = cvssv3Object.has("score")?cvssv3Object.getString("exploitabilityScore"):"";
//										impactScore = cvssv3Object.has("score")?cvssv3Object.getString("impactScore"):"";
//										version = cvssv3Object.has("score")?cvssv3Object.getString("version"):"";
//									}
//									else if(vulnerabilityObject.has("cvssv2"))
//									{
//										JSONObject cvssv2Object = vulnerabilityObject.getJSONObject("cvssv2");
//										baseScore = cvssv2Object.has("score")?cvssv2Object.getFloat("score"):0;
//										attackVector = cvssv2Object.has("accessVector")?cvssv2Object.getString("accessVector"):"";
//										attackComplexity = cvssv2Object.has("accessComplexity")?cvssv2Object.getString("accessComplexity"):"";
//										privilegesRequired = cvssv2Object.has("authenticationr")?cvssv2Object.getString("authenticationr"):"";
//										confidentialityImpact = cvssv2Object.has("confidentialImpact")?cvssv2Object.getString("confidentialImpact"):"";
//										integrityImpact = cvssv2Object.has("integrityImpact")?cvssv2Object.getString("integrityImpact"):"";
//										availabilityImpact = cvssv2Object.has("availabilityImpact")?cvssv2Object.getString("availabilityImpact"):"";
//										baseSeverity = cvssv2Object.has("severity")?cvssv2Object.getString("severity"):"";
//										exploitabilityScore = cvssv2Object.has("exploitabilityScore")?cvssv2Object.getString("exploitabilityScore"):"";
//										impactScore = cvssv2Object.has("impactScore")?cvssv2Object.getString("impactScore"):"";
//										version = cvssv2Object.has("version")?cvssv2Object.getString("version"):"";
//									}
//
//									VulnerabilityDTO vulnerabilityDTO = new VulnerabilityDTO();
//									vulnerabilityDTO.setJarName(fileName);
//									vulnerabilityDTO.setSource(source);
//									vulnerabilityDTO.setVulnerabilityName(vulnerabilityName);
//									vulnerabilityDTO.setSeverity(severity);
//									vulnerabilityDTO.setBaseScore(baseScore);
//									vulnerabilityDTO.setAttackVector(attackVector);
//									vulnerabilityDTO.setAttackComplexity(attackComplexity);
//									vulnerabilityDTO.setPrivilegesRequired(privilegesRequired);
//									vulnerabilityDTO.setUserInteraction(userInteraction);
//									vulnerabilityDTO.setScope(scope);
//									vulnerabilityDTO.setConfidentialityImpact(confidentialityImpact);
//									vulnerabilityDTO.setIntegrityImpact(integrityImpact);
//									vulnerabilityDTO.setAvailabilityImpact(availabilityImpact);
//									vulnerabilityDTO.setBaseSeverity(baseSeverity);
//									vulnerabilityDTO.setExploitabilityScore(exploitabilityScore);
//									vulnerabilityDTO.setImpactScore(impactScore);
//									vulnerabilityDTO.setVersion(version);
//
//									//                            		System.out.println(vulnerabilityDTO.getJarName());
//									vulnerabilityList.add(vulnerabilityDTO);
//								}
//							}
//						}
//						if(vulnerabilityList.size()>0)
//						{
//							vulnerabilitiesMap.put(fileName, vulnerabilityList);
//						}
//					}
//				}
//			}	        
//		}
//		catch(Exception e)
//		{
//			e.printStackTrace();
//		}
//
//		return vulnerabilitiesMap;
//
//	}
//
//	public static void getVulCount(DependencyDTO root, Map<String,Integer> vulCount)
//	{
//		if(root.getVulnerabilities().size()>0)
//		{
//			vulCount.put(root.getGroupId()+"/"+root.getArtifactId()+"/"+root.getVersion(), root.getVulnerabilities().size());			
//			System.out.println(root.getArtifactId()+" - "+root.getVersion()+" - "+root.getVulnerabilities().size());		
////			for(VulnerabilityDTO vul : root.getVulnerabilities())
////			{
////				System.out.println(vul.getVulnerabilityName());
////			}
//		}
//		List<DependencyDTO> children = root.getChildren();
//		for(DependencyDTO child : children)
//		{
//			getVulCount(child, vulCount);
//		}
//	}
//
//	public static int getTotalVulCount(Map<String,Integer> vulCount)
//	{
//		int totalVulCount = 0;
//		for (Integer value : vulCount.values()) {
//			totalVulCount += value;
//		}
//		return totalVulCount;
//	}

}
